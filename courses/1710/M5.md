---
layout: default
title: "Module 5: Categorical Propositions & Syllogisms"
---

# ePortfolio 反思：定言命題不是哲學遊戲，而是量化邏輯的骨架｜13/11

今天 HUMA1710 的課一開始就用一個「神秘中東石油王子來港開演唱會」的笑話切入——香港政府是不是又當「水魚」了？但笑完之後，問題來了：

> 「以下哪些陳述需要知道『所有王子』的個人資料才能判斷真假？」

- **「所有王子都是歌手」** → 要！因為可能最後一個王子根本不會唱歌。
- **「沒有王子是歌手」** → 也要！因為可能最後一個王子就是隱藏的 Ed Sheeran。
- **「有些王子是歌手」** → 不用！只要找到一個會唱歌的王子就成立（∃x）。
- **「有些王子不是歌手」** → 同理，只要找到一個五音不全的王子就夠（∃x¬P(x)）。

這讓我立刻想到 **COMP 2711 裡的量化邏輯（quantifiers）**：

- **∀x P(x)** 需要「全域驗證」→ computational cost 高
- **∃x P(x)** 只要「找到一個反例或正例」→ early termination possible

這不就是我們寫演算法時常說的 **「short-circuit evaluation」** 嗎？比如在 Python 裡寫 `any()` 或 `all()`，底層邏輯根本一模一樣！

### 從 Russell 到謂詞邏輯：日常語言的結構化轉譯

講師沒明說，但這套思維其實承襲自 **Bertrand Russell 的摹狀詞理論（Theory of Descriptions）**——他主張，日常語言充滿模糊，唯有透過 **形式語言（如 ∀, ∃）** 才能精確表達命題的邏輯結構。
這正是我在 **HUMA1922（Analytic Philosophy）** 學到的核心：**哲學問題常是語言問題**，而邏輯是解藥。

而今天學的 **定言命題（Categorical Proposition）**，其實就是量化邏輯在「類與類關係」上的古典版本。四種形式：

| **類型** | **形式**    | **符號邏輯對應**        |
| ------ | --------- | ----------------- |
| **A**  | 所有 S 都是 P | ∀x (S(x) → P(x))  |
| **E**  | 沒有 S 是 P  | ∀x (S(x) → ¬P(x)) |
| **I**  | 有些 S 是 P  | ∃x (S(x) ∧ P(x))  |
| **O**  | 有些 S 不是 P | ∃x (S(x) ∧ ¬P(x)) |

注意：**I 和 O 用的是 ∧，不是 →**！這在 COMP 2711 裡強調過無數次——因為「存在」必須指向「實際個體」，不能只靠條件句。

### 四角對當表（Square of Opposition）：傳統 vs. 現代邏輯的鴻溝

講師說「NSL 說不用背」，但我還是自己畫了個表來記，因為這結構實在太美：

```other
A（所有鳥會飛）
       / \
Contrary  Sub-alternation
     /     \
    E       I
     \     /
Sub-contrary
       \ /
        O（有些鳥不會飛）
```

- **互相矛盾（Contradictory）**：A ↔ ¬O，E ↔ ¬I → 必一真一假 → 這就是 XOR！
（你說「所有鳥都會飛」，我說「有些不會」——我們不可能都對，也不可能都錯。）
- **正對反（Contrary）**：A 與 E → 可同假（例如：有些鳥會飛、有些不會），但不可同真。
- **負對反（Sub-contrary）**：I 與 O → 可同真（現實世界就是如此！），但不可同假。
- **屬涵蘊（Sub-alternation）**：A → I，E → O
→ 如果「所有鳥都會飛」為真，那「有些鳥會飛」當然為真。

但！這裡有個關鍵轉折：**這些關係只在「傳統邏輯（假設類非空）」下成立**。
一旦進入 **現代布爾邏輯（Boolean interpretation）** ——比如討論「獨角獸會魔法」這種空集問題——
**只有「互相矛盾」關係還站得住腳**，其他全崩。

**有點像CS想講的「Garbage in, garbage out」**。
如果 domain 是 empty（比如 S = ∅），那 ∀x P(x) 在邏輯上自動為真（vacuous truth），但這在現實中毫無意義。

### 從哲學到系統設計：為什麼 CS 人該關心定言命題？

乍看之下，A/E/I/O 像是哲學課的抽象遊戲，但仔細想：

- **資料庫查詢**：`SELECT * FROM princes WHERE singer = TRUE` 就是 ∃x P(x)
- **形式驗證（Formal Verification）**：證明「所有輸入都安全」是 ∀x Safe(x)
- **AI 知識表示**：用類別邏輯（如 OWL）建模「醫生 → 人類」、「企鵝 ⊆ 鳥 ∧ ¬會飛」

甚至，**四角對當的矛盾結構**，根本就是 **unit test 與 test coverage 的邏輯基礎**——
你不能只測「正例」，還得測「反例」（O vs. A），否則就是偽陽性。

---

### 反思與連結

這次 lecture 讓我意識到：**定言命題不是過時的哲學遺產，而是量化思維的起點**。
它把日常模糊的「有些」「所有」轉化為可計算、可驗證的邏輯結構——
這正是 **Computer Science 的本質：將模糊世界轉譯為精確指令**。

我過去在 COMP 2711 背過 ∀/∃，在 HUMA1922 討論過 Russell，但直到今天才真正「看到連結」。
這種 **跨模組的整合**（Analytic Philosophy + Discrete Math + Categorical Logic），
正是 ePortfolio 想捕捉的「深度學習」。

> **Artefact**: HUMA1710 Lecture on 13 November 2025;
Supported by *5a. Categorical Proposition.pdf*;
Cross-referenced with COMP 2711 (Quantifiers) and HUMA1922 (Russell’s Theory of Descriptions).

---
# ePortfolio 反思：定言三段論｜18/11

今天課上講的是**定言三段論**（Categorical Syllogism），一開始就強調：判斷一個論證是否對確（valid），**只看形式結構，不看內容真假**。這點其實在 COMP 2711 裡已經接觸過——validity 與 soundness 的區分：就算前提荒謬（例如「所有人都有翅膀」），只要結構正確，論證仍是對確的。

要判斷三段論是否對確，有兩種方法：**范恩圖**（Venn diagrams）和**規則法**（Rules method）。
我自己習慣先畫圖，因為直觀；但考試時可能得用規則法，比較快也比較機械化。NSL 提到 Salmon 的規則版本比較簡潔（適合考試），Copi 的則更詳盡（適合理解），這取捨很合理。

其中一個關鍵概念是**周延**（distribution）——剛聽名字覺得有點玄，但其實就是問：這個詞項是不是談到整個集合？
例如：

- 「所有動物都會死」→「動物」是周延的（談到全部）
- 「Socrates 是動物」→「動物」不周延（只談歸屬）

配合 AEIO 四種命題，周延的模式其實可以記成一個簡單口訣：

- A: 主詞周延（d-u）
- E: 主詞、謂詞都周延（d-d）
- I: 都不周延（u-u）
- O: 謂詞周延（u-d）

我用「du dd uu ud」來記，最後一個「ud」其實可以從前面推，所以重點記前三個就行。雖然中文的「主詞／謂詞」聽起來有點抽象（畢竟母語者不會特別分析語法結構），但轉成英文 subject/predicate 就清楚多了。

規則法本身像套公式：只要違反任一條，論證就不對確。例如中詞必須至少周延一次，否則無法有效連結大詞和小詞。這讓我想到寫程式時的**介面設計**——如果兩個模組之間沒有明確的共通介面（中詞），就無法傳遞訊息。

不過對我來說，**范恩圖還是最直覺的工具**。三個圓圈一畫，前提一標（陰影或打 X），結論自然浮現。這種視覺化方式從中學用到現在，始終有效。考試時我會兩種方法交叉驗證，比較保險。

這堂課也讓我更清楚看到邏輯的發展脈絡：

- 符號邏輯（4/11）：處理原子命題與連接詞
- 定言命題（13/11）：引入量詞與類別關係
- 定言三段論（18/11）：多前提的結構推理

作為 CS 學生，我越來越覺得這些看似抽象的邏輯訓練，其實是**系統化思考的基礎**——無論是寫條件判斷、設計資料庫查詢，還是驗證演算法正確性，本質上都在處理「結構是否成立」的問題。

> **Artefact**: HUMA1710 lecture on 18 November 2025
Supported by *5b. Categorical Syllogism.pdf*;
Cross-referenced with COMP 2711 (Discrete Math) and prior logic modules.

---